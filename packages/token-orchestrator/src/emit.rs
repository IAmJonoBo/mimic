use std::collections::BTreeMap;
use std::fs::{create_dir_all, File};
use std::io::{BufWriter, Write};
use std::path::{Path, PathBuf};

use serde::Serialize;
use serde_json::Value;
use tracing::{info, instrument};

use crate::{ingest::Token, OrchestratorError};

#[derive(Debug, Clone)]
pub struct EmitPaths {
    pub css: PathBuf,
    pub ts: PathBuf,
    pub compose: PathBuf,
    pub dart: PathBuf,
}

#[derive(Debug, Clone, PartialEq, Serialize)]
pub struct EmitArtifacts {
    pub css: String,
    pub ts: String,
    pub compose: String,
    pub dart: String,
}

#[instrument(
    name = "emit.outputs",
    skip(tokens, output_dir),
    fields(token_count = tokens.len(), output = %output_dir.display())
)]
pub fn emit_outputs(tokens: &[Token], output_dir: &Path) -> Result<EmitPaths, OrchestratorError> {
    let artifacts = build_artifacts(tokens);

    let css_dir = output_dir.join("css");
    let ts_dir = output_dir.join("ts");
    let compose_dir = output_dir.join("compose");
    let dart_dir = output_dir.join("dart");

    for dir in [&css_dir, &ts_dir, &compose_dir, &dart_dir] {
        create_dir_all(dir)?;
    }

    let css_path = css_dir.join("tokens.css");
    let ts_path = ts_dir.join("tokens.ts");
    let compose_path = compose_dir.join("Tokens.kt");
    let dart_path = dart_dir.join("tokens.dart");

    write_string(&css_path, &artifacts.css)?;
    write_string(&ts_path, &artifacts.ts)?;
    write_string(&compose_path, &artifacts.compose)?;
    write_string(&dart_path, &artifacts.dart)?;

    info!("token outputs written");

    Ok(EmitPaths {
        css: css_path,
        ts: ts_path,
        compose: compose_path,
        dart: dart_path,
    })
}

pub fn build_artifacts(tokens: &[Token]) -> EmitArtifacts {
    EmitArtifacts {
        css: build_css(tokens),
        ts: build_ts(tokens),
        compose: build_compose(tokens),
        dart: build_dart(tokens),
    }
}

fn write_string(path: &Path, content: &str) -> Result<(), OrchestratorError> {
    let mut writer = BufWriter::new(File::create(path)?);
    writer.write_all(content.as_bytes())?;
    writer.flush()?;
    Ok(())
}

fn build_css(tokens: &[Token]) -> String {
    let mut body = String::from(":root {\n");
    for token in tokens {
        body.push_str("  --");
        body.push_str(&css_identifier(&token.path));
        body.push_str(": ");
        body.push_str(&value_as_string(&token.value));
        body.push_str(";\n");
    }
    body.push_str("}\n");
    body
}

fn build_ts(tokens: &[Token]) -> String {
    let mut map = BTreeMap::new();
    for token in tokens {
        map.insert(ts_identifier(&token.path), value_as_string(&token.value));
    }

    let json = serde_json::to_string_pretty(&map).unwrap_or_else(|_| "{}".into());
    format!("export const tokens = {} as const;\n", json)
}

fn build_compose(tokens: &[Token]) -> String {
    let mut body = String::new();
    body.push_str("@file:Suppress(\"ktlint\")\n");
    body.push_str("package mimic.tokens\n\n");
    body.push_str("object Tokens {\n");
    for token in tokens {
        body.push_str("    const val ");
        body.push_str(&compose_identifier(&token.path));
        body.push_str(": String = \"");
        body.push_str(&value_as_string(&token.value));
        body.push_str("\"\n");
    }
    body.push_str("}\n");
    body
}

fn build_dart(tokens: &[Token]) -> String {
    let mut body = String::from("// Generated by mimic-token-orchestrator\nclass Tokens {\n");
    for token in tokens {
        body.push_str("  static const ");
        body.push_str(&dart_identifier(&token.path));
        body.push_str(" = '");
        body.push_str(&value_as_string(&token.value));
        body.push_str("';\n");
    }
    body.push_str("}\n");
    body
}

fn value_as_string(value: &Value) -> String {
    match value {
        Value::String(s) => s.clone(),
        Value::Number(n) => n.to_string(),
        Value::Bool(b) => b.to_string(),
        other => serde_json::to_string(other).unwrap_or_default(),
    }
}

fn css_identifier(path: &[String]) -> String {
    path.iter()
        .map(|segment| sanitize(segment, true))
        .collect::<Vec<_>>()
        .join("-")
}

fn ts_identifier(path: &[String]) -> String {
    path.iter()
        .map(|segment| sanitize(segment, false))
        .collect::<Vec<_>>()
        .join(".")
}

fn compose_identifier(path: &[String]) -> String {
    path.iter()
        .map(|segment| to_pascal_case(segment))
        .collect::<Vec<_>>()
        .join("")
}

fn dart_identifier(path: &[String]) -> String {
    let mut segments = path.iter();
    if let Some(first) = segments.next() {
        let mut identifier = to_pascal_case(first);
        if let Some(ch) = identifier.chars().next() {
            identifier.replace_range(0..1, &ch.to_lowercase().to_string());
        }
        for segment in segments {
            identifier.push_str(&to_pascal_case(segment));
        }
        identifier
    } else {
        String::new()
    }
}

fn sanitize(segment: &str, lower: bool) -> String {
    let mut sanitized = String::new();
    for ch in segment.chars() {
        if ch.is_ascii_alphanumeric() {
            sanitized.push(if lower {
                ch.to_ascii_lowercase()
            } else {
                ch.to_ascii_lowercase()
            });
        } else {
            sanitized.push(if lower { '-' } else { '.' });
        }
    }
    sanitized
}

fn to_pascal_case(segment: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;
    for ch in segment.chars() {
        if ch.is_ascii_alphanumeric() {
            if capitalize_next {
                result.push(ch.to_ascii_uppercase());
                capitalize_next = false;
            } else {
                result.push(ch.to_ascii_lowercase());
            }
        } else {
            capitalize_next = true;
        }
    }
    if result.is_empty() {
        result.push('X');
    }
    result
}
